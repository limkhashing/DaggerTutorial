package com.kslimweb.daggertutorial.component

import com.kslimweb.daggertutorial.AppConstants.ENGINE_CAPACITY
import com.kslimweb.daggertutorial.AppConstants.HORSE_POWER
import com.kslimweb.daggertutorial.MainActivity
import com.kslimweb.daggertutorial.PerActivity
import com.kslimweb.daggertutorial.module.DieselEngineModule
import com.kslimweb.daggertutorial.module.PetrolEngineModule
import com.kslimweb.daggertutorial.module.WheelsModule
import dagger.BindsInstance
import dagger.Component
import dagger.Subcomponent
import javax.inject.Named

// At some point we need to exit the object graph
// Bind all the dependency into single component / object as exit point
// code will be generated by Dagger automatically when compile project

// by swapping modules we can easily unit test our codes because we can also
// a fake engine module or a fake wheels module
// but we cannot put put two Engine together and
// Dagger would not know which Engine should use

/* Component */
//@PerActivity
//@Component(dependencies = [AppComponent::class], modules = [WheelsModule::class, PetrolEngineModule::class])
//interface ActivityComponent {
//    // provision method
////    fun getCar(): Car
//
//    fun inject(mainActivity: MainActivity)
//
//    // we are responsible for how Builder will do
//    @Component.Builder
//    interface Builder {
//
//        // prefer @BindsInstance over constructor arguments whenever is possible
//        // Dagger only care about the return type in @BindsInstance and it will caused problem
//        // In generated code, using @BindsInstance will get the PetrolEngine since it instantiate directly
//        // Basically, we tell Dagger we want to use PetrolEngine whenever Engine is required
//
//        @BindsInstance
//        fun horsePower(@Named(HORSE_POWER) horsePower: Int): Builder
//
//        @BindsInstance
//        fun engineCapacity(@Named(ENGINE_CAPACITY) engineCapacity: Int): Builder
//
//        fun build() : ActivityComponent
//        fun appComponent(appComponent: AppComponent): Builder
//    }
//}

/* Sub Component */

//@PerActivity
//// sub component can access all the objests in parent component
//@Subcomponent(modules = [WheelsModule::class, DieselEngineModule::class])
//interface ActivityComponent {
//    // provision method
////    fun getCar(): Car
//
//    fun inject(mainActivity: MainActivity)
//}

//@PerActivity
//@Subcomponent(modules = [WheelsModule::class, PetrolEngineModule::class])
//interface ActivityComponent {
//
//    fun inject(mainActivity: MainActivity)
//
//    @Subcomponent.Builder
//    interface Builder {
//        @BindsInstance
//        fun horsePower(@Named(HORSE_POWER) horsePower: Int): Builder
//
//        @BindsInstance
//        fun engineCapacity(@Named(ENGINE_CAPACITY) engineCapacity: Int): Builder
//
//        fun build() : ActivityComponent
//    }
//}

@PerActivity
@Subcomponent(modules = [WheelsModule::class, PetrolEngineModule::class])
interface ActivityComponent {

    fun inject(mainActivity: MainActivity)

    // cannot have both builder and factory in same component

    @Subcomponent.Factory
    interface Factory {
        // at least one abstract method
        // conventionaly name the abstract method as create()
        fun create(@BindsInstance @Named(HORSE_POWER) horsePower: Int,
                   @BindsInstance @Named(ENGINE_CAPACITY) engineCapacity: Int)
                : ActivityComponent
    }
}